From be04ef5e8a8165697fc13ae244551e2e6dfa1808 Mon Sep 17 00:00:00 2001
From: yogurt <yusong1117.u@gmail.com>
Date: Sat, 25 Oct 2025 20:19:25 +0800
Subject: [PATCH] feat: support key-down update

---
 .gitignore       |  4 ++++
 cmd/cvi_update.c | 59 ++++++++++++++++++++++++++++++++++++++++++++++++
 lib/time.c       |  4 ++--
 3 files changed, 65 insertions(+), 2 deletions(-)
 create mode 100644 .gitignore

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000000..3b30332ca8
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,4 @@
+build/
+include/cvi_board_memmap.h
+include/cvipart.h
+include/imgs.h
diff --git a/cmd/cvi_update.c b/cmd/cvi_update.c
index 4a9ad7de74..f06f6d526f 100644
--- a/cmd/cvi_update.c
+++ b/cmd/cvi_update.c
@@ -16,6 +16,7 @@
 #include <blk.h>
 #include <fs.h>
 #include <stdlib.h>
+#include <cvitek/mmio.h>
 
 #define HEADER_SIZE 64
 #ifdef CONFIG_CMD_SAVEENV
@@ -599,6 +600,61 @@ static int _uart_update(void)
 	return ret;
 }
 
+static bool is_key_pressed(void)
+{
+	// Modify the GPIO configuration as needed!!!!!!!!!
+	#define GPIO_GRP 2
+	#define GPIO_PIN 10
+
+	uint8_t gpio_grp = GPIO_GRP, gpio_pin = GPIO_PIN; // XGPIOB[3];
+	printf("gpio_grp = %d gpio_pin = %d\n", gpio_grp, gpio_pin);
+
+	// gpio base addr: gpioa, gpiob, gpioc, gpiod, pwr_gpio;
+	uint32_t gpio_base[5] = { 0x03020000, 0x03021000, 0x03022000, 0x03023000, 0x05021000 };
+	uint32_t gpio_direction_addr = gpio_base[gpio_grp] + 0x4;
+	uint32_t gpio_value_addr = gpio_base[gpio_grp] + 0x50;
+	uint32_t val = 0x1;
+
+	/* pinmux config */
+	mmio_write_32(0x030010f4, 0x3);  /* pinmux: SET XGPIOC[10] AS GPIO mode */
+
+	/* open internel pull up */
+	mmio_write_32(0x03001C24, 0x44); /* pullup: XGPIOC[10] open internel pull up */
+
+	/* gpio input mode */
+	val = mmio_read_32(gpio_direction_addr) & (~(1 << gpio_pin));
+	mmio_write_32(gpio_direction_addr, val);
+
+	/* gpio debouncing */
+	val = (mmio_read_32(gpio_value_addr) >> gpio_pin) & 0x1;
+	printf("key value = %u (key down should be 0)\n", val);
+	if (val == 0) { // key down
+		// wait for debounce
+		mdelay(10);
+		val = (mmio_read_32(gpio_value_addr) >> gpio_pin) & 0x1;
+		printf("repeat key value = %u (key down should be 0)\n", val);
+		return val == 0;
+	}
+	return false; // pressed:true unpressed:false
+}
+
+static void check_update_key(void)
+{
+	if (is_key_pressed()) {
+		printf("Update key is pressed, enter usb update mode...\n");
+		// set boot source flag to usb update
+		mmio_write_32(BOOT_SOURCE_FLAG_ADDR, USB_UPDATE_MAGIC);
+		// set pwm to control led for notice update status
+		mmio_write_32(0x03001008, 0x5);	   /* pinmux: SET SD0_D0 AS PWM[13] mode */
+		mmio_write_32(0x03063008, 10000);  /* 低电平周期：10000*10ns: 100us */
+		mmio_write_32(0x0306300c, 100000); /* 方波周期：100000*10ns: 1000us */
+		mmio_write_32(0x03063040, 0x2);	   /* set pwm13 polarity */
+		mmio_write_32(0x030630d0, 0x2);	   /* set pwm13 output enable */
+		mmio_write_32(0x03063044, 0x0);	   /* stop pwm13 */
+		mmio_write_32(0x03063044, 0x2);	   /* start pwm13 */
+	}
+}
+
 static int do_cvi_update(struct cmd_tbl *cmdtp, int flag, int argc,
 			 char *const argv[])
 {
@@ -607,6 +663,9 @@ static int do_cvi_update(struct cmd_tbl *cmdtp, int flag, int argc,
 	int ret = 1;
 	uint32_t usb_pid = 0;
 
+	// check update key, is key pressed, run usb update
+	check_update_key();
+
 	if (argc == 1) {
 		update_magic = readl((unsigned int *)BOOT_SOURCE_FLAG_ADDR);
 		if (update_magic == UART_UPDATE_MAGIC) {
diff --git a/lib/time.c b/lib/time.c
index 1fb151605b..ef7b69e535 100644
--- a/lib/time.c
+++ b/lib/time.c
@@ -3,7 +3,7 @@
  * (C) Copyright 2000-2009
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  */
-
+#define DEBUG
 #include <common.h>
 #include <bootstage.h>
 #include <dm.h>
@@ -96,7 +96,7 @@ uint64_t notrace get_ticks(void)
 
 		ret = dm_timer_init();
 		if (ret)
-			panic("Could not initialize timer (err %d)\n", ret);
+			return ret;
 #endif
 	}
 
-- 
2.34.1

