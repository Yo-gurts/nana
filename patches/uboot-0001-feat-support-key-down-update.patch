From 75ccc01549bbd4a5a3fb931384883177c110320a Mon Sep 17 00:00:00 2001
From: yogurt <yusong1117.u@gmail.com>
Date: Sat, 25 Oct 2025 20:19:25 +0800
Subject: [PATCH] [feat] support key-down update

---
 cmd/cvi_update.c | 58 ++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/cmd/cvi_update.c b/cmd/cvi_update.c
index 3fc05488ae..530222c629 100644
--- a/cmd/cvi_update.c
+++ b/cmd/cvi_update.c
@@ -15,6 +15,7 @@
 #include <blk.h>
 #include <fs.h>
 #include <stdlib.h>
+#include <cvitek/mmio.h>
 
 #define HEADER_SIZE 64
 #ifdef CONFIG_CMD_SAVEENV
@@ -598,6 +599,60 @@ static int _uart_update(void)
 	return ret;
 }
 
+static bool is_key_pressed(void)
+{
+	// Modify the GPIO configuration as needed!!!!!!!!!
+	#define GPIO_GRP 2
+	#define GPIO_PIN 10
+
+	uint8_t gpio_grp = GPIO_GRP, gpio_pin = GPIO_PIN; // XGPIOB[3];
+	printf("gpio_grp = %d gpio_pin = %d\n", gpio_grp, gpio_pin);
+
+	// gpio base addr: gpioa, gpiob, gpioc, gpiod, pwr_gpio;
+	uint32_t gpio_base[5] = { 0x03020000, 0x03021000, 0x03022000, 0x03023000, 0x05021000 };
+	uint32_t gpio_direction_addr = gpio_base[gpio_grp] + 0x4;
+	uint32_t gpio_value_addr = gpio_base[gpio_grp] + 0x50;
+	uint32_t val = 0x1;
+
+	/* pinmux config */
+	mmio_write_32(0x030010f4, 0x3);  /* pinmux: SET XGPIOC[10] AS GPIO mode */
+
+	/* open internel pull up */
+	mmio_write_32(0x03001C24, 0x44); /* pullup: XGPIOC[10] open internel pull up */
+
+	/* gpio input mode */
+	val = mmio_read_32(gpio_direction_addr) & (~(1 << gpio_pin));
+	mmio_write_32(gpio_direction_addr, val);
+
+	/* gpio debouncing */
+	val = (mmio_read_32(gpio_value_addr) >> gpio_pin) & 0x1;
+	printf("key value = %u (key down should be 0)\n", val);
+	if (!val) {
+		mdelay(10);
+		val = (mmio_read_32(gpio_value_addr) >> gpio_pin) & 0x1;
+		printf("repeat key value = %u (key down should be 0)\n", val);
+		return !val;
+	}
+	return 1; // pressed:1 unpressed:0
+}
+
+static void check_update_key(void)
+{
+	if (!is_key_pressed())
+		return;
+
+	// set boot source flag to usb update
+	mmio_write_32(BOOT_SOURCE_FLAG_ADDR, USB_UPDATE_MAGIC);
+	// set pwm to control led for notice update status
+	mmio_write_32(0x03001008, 0x5);  /* pinmux: SET SD0_D0 AS PWM[13] mode */
+	mmio_write_32(0x03063008, 10000); /* 低电平周期：10000*10ns: 100us */
+	mmio_write_32(0x0306300c, 100000); /* 方波周期：100000*10ns: 1000us */
+	mmio_write_32(0x03063040, 0x2); /* set pwm13 polarity */
+	mmio_write_32(0x030630d0, 0x2); /* set pwm13 output enable */
+	mmio_write_32(0x03063044, 0x0); /* stop pwm13 */
+	mmio_write_32(0x03063044, 0x2); /* start pwm13 */
+}
+
 static int do_cvi_update(struct cmd_tbl *cmdtp, int flag, int argc,
 			 char *const argv[])
 {
@@ -606,6 +661,9 @@ static int do_cvi_update(struct cmd_tbl *cmdtp, int flag, int argc,
 	int ret = 1;
 	uint32_t usb_pid = 0;
 
+	// check update key, is key pressed, run usb update
+	check_update_key();
+
 	if (argc == 1) {
 		update_magic = readl((unsigned int *)BOOT_SOURCE_FLAG_ADDR);
 		if (update_magic == UART_UPDATE_MAGIC) {
-- 
2.34.1

